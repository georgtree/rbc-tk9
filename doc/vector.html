<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>vector</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width:72em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="vector">Vector</h1>
<ul>
<li><a href="#name">Name</a></li>
<li><a href="#synopsis">Synopsis</a></li>
<li><a href="#description">Description</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#vector-indices">Vector indices</a></li>
<li><a href="#vector-operations">Vector operations</a></li>
<li><a href="#instance-operations">Instance operations</a></li>
<li><a href="#c-language-api">C language API</a></li>
<li><a href="#library-routines">Library routines</a></li>
<li><a href="#c-api-example-">C API example</a></li>
<li><a href="#incompatibilities">Incompatibilities</a></li>
</ul>
<h2 id="name">Name</h2>
<p>vector − Vector data type for Tcl</p>
<h2 id="synopsis">Synopsis</h2>
<p><strong>vector create</strong> <em>vecName</em> ?<em>vecName</em> …?
?<em>switches</em>?</p>
<p><strong>vector destroy</strong> <em>vecName</em> ?<em>vecName</em>
…?</p>
<p><strong>vector expr</strong> <em>expression</em></p>
<p><strong>vector names</strong> ?<em>pattern</em> …?</p>
<h2 id="description">Description</h2>
<p>The <strong>vector</strong> command creates a vector of floating
point values. The vector’s components can be manipulated in three ways:
through a Tcl array variable, a Tcl command, or the C API.</p>
<h2 id="introduction">Introduction</h2>
<p>A vector is simply an ordered set of numbers. The components of a
vector are real numbers, indexed by counting numbers.</p>
<p>Vectors are common data structures for many applications. For
example, a graph may use two vectors to represent the X-Y coordinates of
the data plotted. The graph will automatically be redrawn when the
vectors are updated or changed. By using vectors, you can separate data
analysis from the graph widget. This makes it easier, for example, to
add data transformations, such as splines. It’s possible to plot the
same data to in multiple graphs, where each graph presents a different
view or scale of the data.</p>
<p>You could try to use Tcl’s associative arrays as vectors. Tcl arrays
are easy to use. You can access individual elements randomly by
specifying the index, or the set the entire array by providing a list of
index and value pairs for each element. The disadvantages of associative
arrays as vectors lie in the fact they are implemented as hash
tables.</p>
<ul>
<li>There’s no implied ordering to the associative arrays. If you used
vectors for plotting, you would want to insure the second component
comes after the first, an so on. This isn’t possible since arrays are
actually hash tables. For example, you can’t get a range of values
between two indices. Nor can you sort an array.</li>
<li>Arrays consume lots of memory when the number of elements becomes
large (tens of thousands). This is because each element’s index and
value are stored as strings in the hash table.</li>
<li>The C programming interface is unwieldy. Normally with vectors, you
would like to view the Tcl array as you do a C array, as an array of
floats or doubles. But with hash tables, you must convert both the index
and value to and from decimal strings, just to access an element in the
array. This makes it cumbersome to perform operations on the array as a
whole.</li>
</ul>
<p>The <strong>vector</strong> command tries to overcome these
disadvantages while still retaining the ease of use of Tcl arrays. The
<strong>vector</strong> command creates both a new Tcl command and
associate array which are linked to the vector components. You can
randomly access vector components though the elements of array. Not have
all indices are generated for the array, so printing the array (using
the <strong>parray</strong> procedure) does not print out all the
component values. You can use the Tcl command to access the array as a
whole. You can copy, append, or sort vector using its command. If you
need greater performance, or customized behavior, you can write your own
C code to manage vectors.</p>
<h2 id="example">Example</h2>
<p>You create vectors using the <strong>vector</strong> command and its
<strong>create</strong> operation.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a new vector.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>vector <span class="ot">create</span> <span class="ot">y</span>(<span class="dv">50</span>)</span></code></pre></div>
<p>This creates a new vector named <code>y</code>. It has fifty
components, by default, initialized to <code>0.0</code>. In addition,
both a Tcl command and array variable, both named <code>y</code>, are
created. You can use either the command or variable to query or modify
components of the vector.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the first value.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span> <span class="ot">y</span>(<span class="dv">0</span>) <span class="fl">9.25</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">puts</span> <span class="st">&quot;y has [y length] components&quot;</span></span></code></pre></div>
<p>The array <code>y</code> can be used to read or set individual
components of the vector. Vector components are indexed from zero. The
array index must be a number less than the number of components. For
example, it’s an error if you try to set the 51st element of
<code>y</code>.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># This is an error. The vector only has 50 components.</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span> <span class="ot">y</span>(<span class="dv">50</span>) <span class="fl">0.02</span></span></code></pre></div>
<p>You can also specify a range of indices using a colon (:) to separate
the first and last indices of the range.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the first six components of y</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span> <span class="ot">y</span>(<span class="dv">0</span>:<span class="dv">5</span>) <span class="fl">25.2</span></span></code></pre></div>
<p>If you don’t include an index, then it will default to the first
and/or last component of the vector.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Print out all the components of y</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">puts</span> <span class="st">&quot;y = </span><span class="dt">$</span><span class="st">y(:)&quot;</span></span></code></pre></div>
<p>There are special non-numeric indices. The index <code>end</code>,
specifies the last component of the vector. It’s an error to use this
index if the vector is empty (length is zero). The index
<code>++end</code> can be used to extend the vector by one component and
initialize it to a specific value. You can’t read from the array using
this index, though.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extend the vector by one component.</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span> <span class="ot">y</span>(++end) <span class="fl">0.02</span></span></code></pre></div>
<p>The other special indices are <code>min</code> and <code>max</code>.
They return the current smallest and largest components of the
vector.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the bounds of the vector</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">puts</span> <span class="st">&quot;min=</span><span class="dt">$</span><span class="st">y(min) max=</span><span class="dt">$</span><span class="st">y(max)&quot;</span></span></code></pre></div>
<p>To delete components from a vector, simply unset the corresponding
array element. In the following example, the first component of
<code>y</code> is deleted. All the remaining components of
<code>y</code> will be moved down by one index as the length of the
vector is reduced by one.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Delete the first component</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">unset</span> <span class="ot">y</span>(<span class="dv">0</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">puts</span> <span class="st">&quot;new first element is </span><span class="dt">$</span><span class="st">y(0)&quot;</span></span></code></pre></div>
<p>The vector’s Tcl command can also be used to query or set the
vector.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create and set the components of a new vector</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>vector <span class="ot">create</span> <span class="ot">x</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="ot">x</span> <span class="kw">set</span> <span class="kw">{</span> <span class="fl">0.02</span> <span class="fl">0.04</span> <span class="fl">0.06</span> <span class="fl">0.08</span> <span class="fl">0.10</span> <span class="fl">0.12</span> <span class="fl">0.14</span> <span class="fl">0.16</span> <span class="fl">0.18</span> <span class="fl">0.20</span> <span class="kw">}</span></span></code></pre></div>
<p>Here we’ve created a vector <code>x</code> without a initial length
specification. In this case, the length is zero. The
<strong>set</strong> operation resets the vector, extending it and
setting values for each new component.</p>
<p>There are several operations for vectors. The <strong>range</strong>
operation lists the components of a vector between two indices.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># List the components</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">puts</span> <span class="st">&quot;x = [x range 0 end]&quot;</span></span></code></pre></div>
<p>You can search for a particular value using the
<strong>search</strong> operation. It returns a list of indices of the
components with the same value. If no component has the same value, it
returns <code>""</code>.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Find the index of the biggest component</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span> indices <span class="kw">[</span><span class="ot">x</span> <span class="ot">search</span> <span class="dt">$x</span>(max)<span class="kw">]</span></span></code></pre></div>
<p>Other operations copy, append, or sort vectors. You can append
vectors or new values onto an existing vector with the
<strong>append</strong> operation.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Append assorted vectors and values to x</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ot">x</span> <span class="kw">append</span> x2 x3 <span class="kw">{</span> <span class="fl">2.3</span> <span class="fl">4.5</span> <span class="kw">}</span> x4</span></code></pre></div>
<p>The <strong>sort</strong> operation sorts the vector. If any
additional vectors are specified, they are rearranged in the same order
as the vector. For example, you could use it to sort data points
represented by x and y vectors.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Sort the data points</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">x</span> sort <span class="ot">y</span></span></code></pre></div>
<p>The vector <code>x</code> is sorted while the components of
<code>y</code> are rearranged so that the original x,y coordinate pairs
are retained.</p>
<p>The <strong>expr</strong> operation lets you perform arithmetic on
vectors. The result is stored in the vector.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Add the two vectors and a scalar</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="ot">x</span> <span class="kw">expr</span> <span class="kw">{</span> <span class="ot">x</span> + <span class="ot">y</span> <span class="kw">}</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="ot">x</span> <span class="kw">expr</span> <span class="kw">{</span> <span class="ot">x</span> * <span class="dv">2</span> <span class="kw">}</span></span></code></pre></div>
<p>When a vector is modified, resized, or deleted, it may trigger
call-backs to notify the clients of the vector. For example, when a
vector used in the <strong>graph</strong> widget is updated, the vector
automatically notifies the widget that it has changed. The graph can
then redrawn itself at the next idle point. By default, the notification
occurs when Tk is next idle. This way you can modify the vector many
times without incurring the penalty of the graph redrawing itself for
each change. You can change this behavior using the
<strong>notify</strong> operation.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Make vector x notify after every change</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">x</span> notify always</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Never notify</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="ot">x</span> notify never</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Force notification now</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="ot">x</span> notify now</span></code></pre></div>
<p>To delete a vector, use the <strong>vector delete</strong> command.
Both the vector and its corresponding Tcl command are destroyed.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove vector x</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>vector <span class="kw">destroy</span> <span class="ot">x</span></span></code></pre></div>
<h2 id="syntax">Syntax</h2>
<p>Vectors are created using the <strong>vector create</strong>
operation. The <strong>create</strong> operation can be invoked in one
of three forms:</p>
<p><strong>vector create</strong> <em>vecName</em></p>
<p>This creates a new vector <em>vecName</em> which initially has no
components.</p>
<p><strong>vector create</strong> <em>vecName</em>(<em>size</em>)</p>
<p>This second form creates a new vector which will contain
<em>size</em> number of components. The components will be indexed
starting from zero (0). The default value for the components is
<code>0.0</code>.</p>
<p><strong>vector create</strong>
<em>vecName</em>(<em>first</em>:<em>last</em>)</p>
<p>The last form creates a new vector of indexed <em>first</em> through
<em>last</em>. <em>First</em> and <em>last</em> can be any integer value
so long as <em>first</em> is less than <em>last</em>.</p>
<p>Vector names must start with a letter and consist of letters, digits,
or underscores.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Error: must start with letter</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>vector <span class="ot">create</span> <span class="dv">1</span>abc</span></code></pre></div>
<p>You can automatically generate vector names using the
“<code>#auto</code>” vector name. The <strong>create</strong> operation
will generate a unique vector name.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span> vec <span class="kw">[</span>vector <span class="ot">create</span> #auto<span class="kw">]</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">puts</span> <span class="st">&quot;</span><span class="dt">$</span><span class="st">vec has [</span><span class="dt">$</span><span class="st">vec length] components&quot;</span></span></code></pre></div>
<h2 id="vector-indices">Vector indices</h2>
<p>Vectors are indexed by integers. You can access the individual vector
components via its array variable or Tcl command. The string
representing the index can be an integer, a numeric expression, a range,
or a special keyword.</p>
<p>The index must lie within the current range of the vector, otherwise
an an error message is returned. Normally the indices of a vector are
start from 0. But you can use the <strong>offset</strong> operation to
change a vector’s indices on-the-fly.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">puts</span> <span class="dt">$vecName</span>(<span class="dv">0</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>vecName offset<span class="ot"> -5</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">puts</span> <span class="dt">$vecName</span>(-<span class="dv">5</span>)</span></code></pre></div>
<p>You can also use numeric expressions as indices. The result of the
expression must be an integer value.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span> n <span class="dv">21</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span> vecName(<span class="dt">$n</span>+<span class="dv">3</span>) <span class="fl">50.2</span></span></code></pre></div>
<p>The following special non-numeric indices are available:
<code>min</code>, <code>max</code>, <code>end</code>, and
<code>++end</code>.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">puts</span> <span class="st">&quot;min = </span><span class="dt">$</span><span class="st">vecName(</span><span class="dt">$</span><span class="st">min)&quot;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span> vecName(end)<span class="ot"> -1</span><span class="fl">.2</span></span></code></pre></div>
<p>The indices <code>min</code> and <code>max</code> will return the
minimum and maximum values of the vector. The index <code>end</code>
returns the value of the last component in the vector. The index
<code>++end</code> is used to append new value onto the vector. It
automatically extends the vector by one component and sets its
value.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Append an new component to the end</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span> vecName(++end) <span class="fl">3.2</span></span></code></pre></div>
<p>A range of indices can be indicated by a colon (:).</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the first six components to 1.0</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">set</span> vecName(<span class="dv">0</span>:<span class="dv">5</span>) <span class="fl">1.0</span></span></code></pre></div>
<p>If no index is supplied the first or last component is assumed.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Print the values of all the components</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="kw">puts</span> <span class="dt">$vecName</span>(:)</span></code></pre></div>
<h2 id="vector-operations">Vector operations</h2>
<ul>
<li><p><strong>vector create</strong> <em>vecName</em>?(<em>size</em>)?
… ?<em>switches</em>?</p>
<p>The <strong>create</strong> operation creates a new vector
<em>vecName</em>. Both a Tcl command and array variable <em>vecName</em>
are also created. The name <em>vecName</em> must be unique, so another
Tcl command or array variable can not already exist in that scope. You
can access the components of the vector using its variable. If you
change a value in the array, or unset an array element, the vector is
updated to reflect the changes. When the variable <em>vecName</em> is
unset, the vector and its Tcl command are also destroyed.</p>
<p>The vector has optional switches that affect how the vector is
created. They are as follows:</p>
<ul>
<li><p><strong>−variable</strong> <em>varName</em> - Specifies the name
of a Tcl variable to be mapped to the vector. If the variable already
exists, it is first deleted, then recreated. If <em>varName</em> is the
empty string, then no variable will be mapped. You can always map a
variable back to the vector using the vector’s <strong>variable</strong>
operation.</p></li>
<li><p><strong>−command</strong> <em>cmdName</em> - Maps a Tcl command
to the vector. The vector can be accessed using <em>cmdName</em> and one
of the vector instance operations. A Tcl command by that name cannot
already exist. If <em>cmdName</em> is the empty string, no command
mapping will be made.</p></li>
<li><p><strong>−watchunset</strong> <em>boolean</em> - Indicates that
the vector should automatically delete itself if the variable associated
with the vector is unset. By default, the vector will not be deleted.
This is different from previous releases. Set <em>boolean</em> to “true”
to get the old behavior.</p></li>
</ul></li>
<li><p><strong>vector destroy</strong> <em>vecName</em> ?<em>vecName
…</em>?</p></li>
<li><p><strong>vector expr</strong> <em>expression</em></p>
<p>All binary operators take vectors as operands (remember that numbers
are treated as one-component vectors). The exact action of binary
operators depends upon the length of the second operand. If the second
operand has only one component, then each element of the first vector
operand is computed by that value. For example, the expression “x * 2”
multiples all elements of the vector x by 2. If the second operand has
more than one component, both operands must be the same length. Each
pair of corresponding elements are computed. So “x + y” adds the the
first components of x and y together, the second, and so on.</p>
<p>The valid operators are listed below, grouped in decreasing order of
precedence:</p></li>
</ul>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Operator</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>− !</strong></td>
<td style="text-align: left;">Unary minus and logical NOT. The unary
minus flips the sign of each component in the vector. The logical not
operator returns a vector of whose values are 0.0 or 1.0. For each
non-zero component 1.0 is returned, 0.0 otherwise.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>^</strong></td>
<td style="text-align: left;">Exponentiation.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>* / %</strong></td>
<td style="text-align: left;">Multiply, divide, remainder.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>+ −</strong></td>
<td style="text-align: left;">Add and subtract.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>&lt;&lt; &gt;&gt;</strong></td>
<td style="text-align: left;">Left and right shift. Circularly shifts
the values of the vector (not implemented yet).</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>&lt; &gt; &lt;=
&gt;=</strong></td>
<td style="text-align: left;">Boolean less, greater, less than or equal,
and greater than or equal. Each operator returns a vector of ones and
zeros. If the condition is true, 1.0 is the component value, 0.0
otherwise.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>== !=</strong></td>
<td style="text-align: left;">Boolean equal and not equal. Each operator
returns a vector of ones and zeros. If the condition is true, 1.0 is the
component value, 0.0 otherwise.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>|</strong></td>
<td style="text-align: left;">Bit-wise OR. (Not implemented).</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>&amp;&amp;</strong></td>
<td style="text-align: left;">Logical AND. Produces a 1 result if both
operands are non-zero, 0 otherwise.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>||</strong></td>
<td style="text-align: left;">Logical OR. Produces a 0 result if both
operands are zero, 1 otherwise.</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><em>x</em><strong>?</strong><em>y</em><strong>:</strong><em>z</em></td>
<td style="text-align: left;">If-then-else, as in C. (Not implemented
yet).</td>
</tr>
</tbody>
</table>
<p>See the C manual for more details on the results produced by each
operator. All of the binary operators group left-to-right within the
same precedence level.</p>
<p>Several mathematical functions are supported for vectors. Each of the
following functions invokes the math library function of the same name;
see the manual entries for the library functions for details on what
they do. The operation is applied to all elements of the vector
returning the results:</p>
<ul>
<li><strong>acos</strong></li>
<li><strong>cos</strong></li>
<li><strong>hypot</strong></li>
<li><strong>sinh</strong></li>
<li><strong>asin</strong></li>
<li><strong>cosh</strong></li>
<li><strong>log</strong></li>
<li><strong>sqrt</strong></li>
<li><strong>atan</strong></li>
<li><strong>exp</strong></li>
<li><strong>log10</strong></li>
<li><strong>tan</strong></li>
<li><strong>ceil</strong></li>
<li><strong>floor</strong></li>
<li><strong>sin</strong></li>
<li><strong>tanh</strong></li>
</ul>
<p>Additional functions are: | Function | Description |
|:————|:—————————————————————————————————————————————————————————————————————————————–|
| <strong>abs</strong> | Returns the absolute value of each component. |
| <strong>random</strong> | Returns a vector of non-negative values
uniformly distributed between [0.0, 1.0) using <em>drand48</em>. The
seed comes from the internal clock of the machine or may be set manual
with the srandom function. | | <strong>round</strong> | Rounds each
component of the vector. | | <strong>srandom</strong> | Initializes the
random number generator using <em>srand48</em>. The high order 32-bits
are set using the integral portion of the first vector component. All
other components are ignored. The low order 16-bits are set to an
arbitrary value. |</p>
<p>The following functions return a single value:</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>adev</strong></td>
<td style="text-align: left;">Returns the average deviation (defined as
the sum of the absolute values of the differences between component and
the mean, divided by the length of the vector).</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>kurtosis</strong></td>
<td style="text-align: left;">Returns the degree of peakedness (fourth
moment) of the vector.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>length</strong></td>
<td style="text-align: left;">Returns the number of components in the
vector.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>max</strong></td>
<td style="text-align: left;">Returns the vector’s maximum value.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>mean</strong></td>
<td style="text-align: left;">Returns the mean value of the vector.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>median</strong></td>
<td style="text-align: left;">Returns the median of the vector.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>min</strong></td>
<td style="text-align: left;">Returns the vector’s minimum value.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>q1</strong></td>
<td style="text-align: left;">Returns the first quartile of the
vector.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>q3</strong></td>
<td style="text-align: left;">Returns the third quartile of the
vector.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>prod</strong></td>
<td style="text-align: left;">Returns the product of the
components.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>sdev</strong></td>
<td style="text-align: left;">Returns the standard deviation (defined as
the square root of the variance) of the vector.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>skew</strong></td>
<td style="text-align: left;">Returns the skewness (or third moment) of
the vector. This characterizes the degree of asymmetry of the vector
about the mean.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>sum</strong></td>
<td style="text-align: left;">Returns the sum of the components.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>var</strong></td>
<td style="text-align: left;">Returns the variance of the vector. The
sum of the squared differences between each component and the mean is
computed. The variance is the sum divided by the length of the vector
minus 1.</td>
</tr>
</tbody>
</table>
<p>The last set returns a vector of the same length as the argument.</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 87%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>norm</strong></td>
<td style="text-align: left;">Scales the values of the vector to lie in
the range [0.0..1.0].</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>sort</strong></td>
<td style="text-align: left;">Returns the vector components sorted in
ascending order.</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>vector names</strong> ?<em>pattern</em>?</li>
</ul>
<h2 id="instance-operations">Instance operations</h2>
<p>You can also use the vector’s Tcl command to query or modify it. The
general form is</p>
<ul>
<li><p><em>vecName operation</em> ?<em>arg</em>? …</p>
<p>Both <em>operation</em> and its arguments determine the exact
behavior of the command. The operations available for vectors are listed
below.</p></li>
<li><p><em>vecName</em> <strong>append</strong> <em>item</em>
?<em>item</em>? …</p>
<p>Appends the component values from <em>item</em> to <em>vecName</em>.
<em>Item</em> can be either the name of a vector or a list of numeric
values.</p></li>
<li><p><em>vecName</em> <strong>binread</strong> <em>channel</em>
?<em>length</em>? ?<em>switches</em>?</p>
<p>Reads binary values from a Tcl channel. Values are either appended to
the end of the vector or placed at a given index (using the
<strong>−at</strong> option), overwriting existing values. Data is read
until EOF is found on the channel or a specified number of values
<em>length</em> are read (note that this is not necessarily the same as
the number of bytes). The following switches are supported:</p>
<ul>
<li><p><strong>−swap</strong> - Swap bytes and words. The default endian
is the host machine.</p></li>
<li><p><strong>−at</strong> <em>index</em> - New values will start at
vector index <em>index</em>. This will overwrite any current
values.</p></li>
<li><p><strong>−format</strong> <em>format</em> - Specifies the format
of the data. <em>Format</em> can be one of the following:
<code>i1</code>, <code>i2</code>, <code>i4</code>, <code>i8</code>,
<code>u1</code>, <code>u2</code>, <code>u4</code>, <code>u8</code>,
<code>r4</code>, <code>r8</code>, or <code>r16</code>. The number
indicates the number of bytes required for each value. The letter
indicates the type: <code>i</code> for signed, <code>u</code> for
unsigned, <code>r</code> or real. The default format is
<code>r16</code>.</p></li>
</ul></li>
<li><p><em>vecName</em> <strong>clear</strong></p>
<p>Clears the element indices from the array variable associated with
<em>vecName</em>. This doesn’t affect the components of the vector. By
default, the number of entries in the Tcl array doesn’t match the number
of components in the vector. This is because its too expensive to
maintain decimal strings for both the index and value for each
component. Instead, the index and value are saved only when you read or
write an element with a new index. This command removes the index and
value strings from the array. This is useful when the vector is
large.</p></li>
<li><p><em>vecName</em> <strong>delete</strong> <em>index</em>
?<em>index</em>? …</p>
<p>Deletes the <em>index</em>th component from the vector
<em>vecName</em>. <em>Index</em> is the index of the element to be
deleted. This is the same as unsetting the array variable element
<em>index</em>. The vector is compacted after all the indices have been
deleted.</p></li>
<li><p><em>vecName</em> <strong>dup</strong> <em>destName</em></p>
<p>Copies <em>vecName</em> to <em>destName</em>. <em>DestName</em> is
the name of a destination vector. If a vector <em>destName</em> already
exists, it is overwritten with the components of <em>vecName</em>.
Otherwise a new vector is created.</p></li>
<li><p><em>vecName</em> <strong>expr</strong> <em>expression</em></p>
<p>Computes the expression and resets the values of the vector
accordingly. Both scalar and vector math operations are allowed. All
values in expressions are either real numbers or names of vectors. All
numbers are treated as one component vectors.</p></li>
<li><p><em>vecName</em> <strong>length</strong> ?<em>newSize</em>?</p>
<p>Queries or resets the number of components in <em>vecName</em>.
<em>NewSize</em> is a number specifying the new size of the vector. If
<em>newSize</em> is smaller than the current size of <em>vecName</em>,
<em>vecName</em> is truncated. If <em>newSize</em> is greater, the
vector is extended and the new components are initialized to
<code>0.0</code>. If no <em>newSize</em> argument is present, the
current length of the vector is returned.</p></li>
<li><p><em>vecName</em> <strong>merge</strong> <em>srcName</em>
?<em>srcName</em>? …</p>
<p>Merges the named vectors into a single vector. The resulting vector
is formed by merging the components of each source vector one index at a
time.</p></li>
<li><p><em>vecName</em> <strong>notify</strong> <em>keyword</em></p>
<p>Controls how vector clients are notified of changes to the vector.
The exact behavior is determined by <em>keyword</em>.</p>
<ul>
<li><code>always</code> - Indicates that clients are to be notified
immediately whenever the vector is updated.</li>
<li><code>never</code> - Indicates that no clients are to be
notified.</li>
<li><code>whenidle</code> - Indicates that clients are to be notified at
the next idle point whenever the vector is updated.</li>
<li><code>now</code> - If any client notifications is currently pending,
they are notified immediately.</li>
<li><code>cancel</code> - Cancels pending notifications of clients using
the vector.</li>
<li><code>pending</code> - Returns <code>1</code> if a client
notification is pending, and <code>0</code> otherwise.</li>
</ul></li>
<li><p><em>vecName</em> <strong>offset</strong> ?<em>value</em>?</p>
<p>Shifts the indices of the vector by the amount specified by
<em>value</em>. <em>Value</em> is an integer number. If no
<em>value</em> argument is given, the current offset is
returned.</p></li>
<li><p><em>vecName</em> <strong>populate</strong> <em>destName</em>
?<em>density</em>?</p>
<p>Creates a vector <em>destName</em> which is a superset of
<em>vecName</em>. <em>DestName</em> will include all the components of
<em>vecName</em>, in addition the interval between each of the original
components will contain a <em>density</em> number of new components,
whose values are evenly distributed between the original components
values. This is useful for generating abscissas to be interpolated along
a spline.</p></li>
<li><p><em>vecName</em> <strong>range</strong> <em>firstIndex</em>
?<em>lastIndex</em>? …</p>
<p>Returns a list of numeric values representing the vector components
between two indices. Both <em>firstIndex</em> and <em>lastIndex</em> are
indices representing the range of components to be returned. If
<em>lastIndex</em> is less than <em>firstIndex</em>, the components are
listed in reverse order.</p></li>
<li><p><em>vecName</em> <strong>search</strong> <em>value</em>
?<em>value</em>?</p>
<p>Searches for a value or range of values among the components of
<em>vecName</em>. If one <em>value</em> argument is given, a list of
indices of the components which equal <em>value</em> is returned. If a
second <em>value</em> is also provided, then the indices of all
components which lie within the range of the two values are returned. If
no components are found, then <code>""</code> is returned.</p></li>
<li><p><em>vecName</em> <strong>set</strong> <em>item</em></p>
<p>Resets the components of the vector to <em>item</em>. <em>Item</em>
can be either a list of numeric expressions or another vector.</p></li>
<li><p><em>vecName</em> <strong>seq</strong> <em>start</em>
?<em>finish</em>? ?<em>step</em>?</p>
<p>Generates a sequence of values starting with the value
<em>start</em>. <em>Finish</em> indicates the terminating value of the
sequence. The vector is automatically resized to contain just the
sequence. If three arguments are present, <em>step</em> designates the
interval.</p>
<p>With only two arguments (no <em>finish</em> argument), the sequence
will continue until the vector is filled. With one argument, the
interval defaults to 1.0.</p></li>
<li><p><em>vecName</em> <strong>sort</strong>
?<strong>-reverse</strong>? ?<em>argName</em>? …</p>
<p>Sorts the vector <em>vecName</em> in increasing order. If the
<strong>-reverse</strong> flag is present, the vector is sorted in
decreasing order. If other arguments <em>argName</em> are present, they
are the names of vectors which will be rearranged in the same manner as
<em>vecName</em>. Each vector must be the same length as
<em>vecName</em>. You could use this to sort the x vector of a graph,
while still retaining the same x,y coordinate pairs in a y
vector.</p></li>
<li><p><em>vecName</em> <strong>variable</strong> <em>varName</em></p>
<p>Maps a Tcl variable to the vector, creating another means for
accessing the vector. The variable <em>varName</em> can’t already exist.
This overrides any current variable mapping the vector may
have.</p></li>
</ul>
<h2 id="c-language-api">C language API</h2>
<p>You can create, modify, and destroy vectors from C code, using
library routines. You need to include the header file
<code>rbc.h</code>. It contains the definition of the structure
<strong>Rbc_Vector</strong>, which represents the vector. It appears
below.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> Rbc_Vector_s <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="op">*</span>valueArr<span class="op">;</span> <span class="co">/* Array of values (possibly malloc-ed) */</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numValues<span class="op">;</span> <span class="co">/* Number of values in the array */</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arraySize<span class="op">;</span> <span class="co">/* Size of the allocated space */</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> min<span class="op">,</span> max<span class="op">;</span> <span class="co">/* Minimum and maximum values in the vector */</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dirty<span class="op">;</span> <span class="co">/* Indicates if the vector has been updated */</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> reserved<span class="op">;</span> <span class="co">/* Reserved for future use */</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> Rbc_Vector<span class="op">;</span></span></code></pre></div>
<p>The field <em>valueArr</em> points to memory holding the vector
components. The components are stored in a double precision array, whose
size size is represented by <em>arraySize</em>. <em>NumValues</em> is
the length of vector. The size of the array is always equal to or larger
than the length of the vector. <em>Min</em> and <em>max</em> are minimum
and maximum component values.</p>
<h2 id="library-routines">Library routines</h2>
<p>The following routines are available from C to manage vectors.
Vectors are identified by the vector name.</p>
<ul>
<li><p><strong>Rbc_CreateVector</strong></p>
<ul>
<li><p>Synopsis:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> Rbc_CreateVector<span class="op">(</span>Tcl_Interp <span class="op">*</span>interp<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>name<span class="op">,</span> <span class="dt">int</span> size<span class="op">,</span> Rbc_Vector <span class="op">**</span>vecPtrPtr<span class="op">)</span></span></code></pre></div></li>
<li><p>Description:</p>
<p>Creates a new vector <em>vecName</em> with a length of <em>size</em>.
<strong>Rbc_CreateVector</strong> creates both a new Tcl command and
array variable <em>vecName</em>. Neither a command nor variable named
<em>vecName</em> can already exist. A pointer to the vector is placed
into <em>vecPtrPtr</em>.</p></li>
<li><p>Results:</p>
<p>Returns <code>TCL_OK</code> if the vector is successfully created. If
<em>length</em> is negative, a Tcl variable or command <em>vecName</em>
already exists, or memory cannot be allocated for the vector, then
<code>TCL_ERROR</code> is returned and <em>interp-&gt;result</em> will
contain an error message.</p></li>
</ul></li>
<li><p><strong>Rbc_GetVector</strong></p>
<ul>
<li><p>Synopsis:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> Rbc_GetVector <span class="op">(</span>Tcl_Interp <span class="op">*</span>interp<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>vecName<span class="op">,</span> Rbc_Vector <span class="op">**</span>vecPtrPtr<span class="op">)</span></span></code></pre></div></li>
<li><p>Description:</p>
<p>Retrieves the vector <em>vecName</em>. <em>VecName</em> is the name
of a vector which must already exist. <em>VecPtrPtr</em> will point be
set to the address of the vector.</p></li>
<li><p>Results:</p>
<p>Returns <code>TCL_OK</code> if the vector is successfully retrieved.
If <em>vecName</em> is not the name of a vector, then
<code>TCL_ERROR</code> is returned and <em>interp-&gt;result</em> will
contain an error message.</p></li>
</ul></li>
<li><p><strong>Rbc_ResetVector</strong></p>
<ul>
<li><p>Synopsis:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> Rbc_ResetVector <span class="op">(</span>Rbc_Vector <span class="op">*</span>vecPtr<span class="op">,</span> <span class="dt">double</span> <span class="op">*</span>dataArr<span class="op">,</span> <span class="dt">int</span> nValues<span class="op">,</span> <span class="dt">int</span> arraySize<span class="op">,</span> Tcl_FreeProc <span class="op">*</span>freeProc<span class="op">)</span></span></code></pre></div></li>
<li><p>Description:</p>
<p>Resets the components of the vector pointed to by <em>vecPtr</em>.
Calling <strong>Rbc_ResetVector</strong> will trigger the vector to
dispatch notifications to its clients. <em>DataArr</em> is the array of
doubles which represents the vector data. <em>NumValues</em> is the
number of elements in the array. <em>ArraySize</em> is the actual size
of the array (the array may be bigger than the number of values stored
in it). <em>FreeProc</em> indicates how the storage for the vector
component array (<em>dataArr</em>) was allocated. It is used to
determine how to reallocate memory when the vector is resized or
destroyed. It must be <code>TCL_DYNAMIC</code>, <code>TCL_STATIC</code>,
<code>TCL_VOLATILE</code>, or a pointer to a function to free the memory
allocated for the vector array. If <em>freeProc</em> is
<code>TCL_VOLATILE</code>, it indicates that <em>dataArr</em> must be
copied and saved. If <em>freeProc</em> is <code>TCL_DYNAMIC</code>, it
indicates that <em>dataArr</em> was dynamically allocated and that Tcl
should free <em>dataArr</em> if necessary. <code>Static</code> indicates
that nothing should be done to release storage for
<em>dataArr</em>.</p></li>
<li><p>Results:</p>
<p>A standard Tcl result. If the new array size is invalid, TCL_ERROR is
returned. Otherwise TCL_OK is returned and the new vector data is
recorded.</p></li>
</ul></li>
<li><p><strong>Rbc_ResizeVector</strong></p>
<ul>
<li><p>Synopsis:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> Rbc_ResizeVector <span class="op">(</span>Rbc_Vector <span class="op">*</span>vecPtr<span class="op">,</span> <span class="dt">int</span> nValues<span class="op">)</span></span></code></pre></div></li>
<li><p>Description:</p>
<p>Resets the length of the vector pointed to by <em>vecPtr</em> to
<em>newSize</em>. If <em>newSize</em> is smaller than the current size
of the vector, it is truncated. If <em>newSize</em> is greater, the
vector is extended and the new components are initialized to
<code>0.0</code>. Calling <strong>Rbc_ResetVector</strong> will trigger
the vector to dispatch notifications.</p></li>
<li><p>Results:</p>
<p>Returns <code>TCL_OK</code> if the vector is successfully resized. If
<em>newSize</em> is negative or memory can not be allocated for the
vector, then <code>TCL_ERROR</code> is returned and
<em>interp-&gt;result</em> will contain an error message.</p></li>
</ul></li>
<li><p><strong>Rbc_VectorExists2</strong></p>
<ul>
<li><p>Synopsis:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> Rbc_VectorExists2 <span class="op">(</span>Tcl_Interp <span class="op">*</span>ip<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>name<span class="op">)</span></span></code></pre></div></li>
<li><p>Description:</p>
<p>Indicates if a vector named <em>vecName</em> exists in
<em>interp</em>.</p></li>
<li><p>Results:</p>
<p>Returns 1 is the vector still exists, 0 otherwise.</p></li>
</ul></li>
<li><p><strong>Rbc_NameOfVectorId</strong></p>
<ul>
<li><p>Synopsis:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>Rbc_NameOfVector <span class="op">(</span>Rbc_Vector <span class="op">*</span>vecPtr<span class="op">)</span></span></code></pre></div></li>
<li><p>Description:</p>
<p>Returns the name of the vector (and array variable).</p></li>
<li><p>Results:</p>
<p>The name of the array variable is returned.</p></li>
</ul></li>
<li><p><strong>Rbc_VectorData</strong></p>
<ul>
<li><p>Synopsis:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> <span class="op">*</span>Rbc_VectorData <span class="op">(</span>Rbc_Vector <span class="op">*</span>v<span class="op">)</span></span></code></pre></div></li>
<li><p>Description:</p>
<p>Returns array of vector data.</p></li>
<li><p>Results:</p>
<p>Array of vector values.</p></li>
</ul></li>
<li><p><strong>Rbc_VectorLength</strong></p>
<ul>
<li><p>Synopsis:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> Rbc_VectorLength <span class="op">(</span>Rbc_Vector <span class="op">*</span>v<span class="op">)</span></span></code></pre></div></li>
<li><p>Description:</p>
<p>Return length of the vector.</p></li>
<li><p>Results:</p>
<p>Length of the vector</p></li>
</ul></li>
<li><p><strong>Rbc_VectorDirty</strong></p>
<ul>
<li><p>Synopsis:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> Rbc_VectorDirty <span class="op">(</span>Rbc_Vector <span class="op">*</span>v<span class="op">)</span></span></code></pre></div></li>
<li><p>Description:</p>
<p>Check if the vector was updated</p></li>
<li><p>Results:</p>
<p>One if vector was updated, and zero if not</p></li>
</ul></li>
<li><p><strong>Rbc_FreeVector</strong></p>
<ul>
<li><p>Synopsis:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Rbc_FreeVector <span class="op">(</span>Rbc_Vector <span class="op">*</span>v<span class="op">)</span></span></code></pre></div></li>
<li><p>Description:</p>
<p>Removes the memory and frees resources associated with the
vector.</p>
<ul>
<li>Removes the trace and the Tcl array variable and unsets the
variable.</li>
<li>Notifies clients of the vector that the vector is being
destroyed.</li>
<li>Removes any clients that are left after notification.</li>
<li>Frees the memory (if necessary) allocated for the array.</li>
<li>Removes the entry from the hash table of vectors.</li>
<li>Frees the memory allocated for the name.</li>
</ul></li>
<li><p>Results:</p>
<p>None</p></li>
</ul></li>
</ul>
<h2 id="c-api-example">C API example</h2>
<p>The following example opens a file of binary data and stores it in an
array of doubles. The array size is computed from the size of the file.
If the vector “data” exists, calling <strong>Rbc_VectorExists2</strong>,
<strong>Rbc_GetVector</strong> is called to get the pointer to the
vector. Otherwise the routine <strong>Rbc_CreateVector</strong> is
called to create a new vector and returns a pointer to it. Just like the
Tcl interface, both a new Tcl command and array variable are created
when a new vector is created. It doesn’t make any difference what the
initial size of the vector is since it will be reset shortly. The vector
is updated when <strong>Rbc_ResetVector</strong> is called.
<strong>Rbc_ResetVector</strong> makes the changes visible to the Tcl
interface and other vector clients (such as a graph widget).</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;tcl.h&gt;</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;rbc.h&gt;</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>Rbc_Vector <span class="op">*</span>vecPtr<span class="op">;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> <span class="op">*</span>newArr<span class="op">;</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="dt">FILE</span> <span class="op">*</span>f<span class="op">;</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> stat statBuf<span class="op">;</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> numBytes<span class="op">,</span> numValues<span class="op">;</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> fopen<span class="op">(</span><span class="st">&quot;binary.dat&quot;</span><span class="op">,</span> <span class="st">&quot;r&quot;</span><span class="op">);</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>fstat<span class="op">(</span>fileno<span class="op">(</span>f<span class="op">),</span> <span class="op">&amp;</span>statBuf<span class="op">);</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>numBytes <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span>statBuf<span class="op">.</span>st_size<span class="op">;</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="co">/* Allocate an array big enough to hold all the data */</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>newArr <span class="op">=</span> <span class="op">(</span><span class="dt">double</span> <span class="op">*)</span>malloc<span class="op">(</span>numBytes<span class="op">);</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>numValues <span class="op">=</span> numBytes <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">);</span></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>fread<span class="op">((</span><span class="dt">void</span> <span class="op">*)</span>newArr<span class="op">,</span> numValues<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">),</span> f<span class="op">);</span></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>fclose<span class="op">(</span>f<span class="op">);</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>Rbc_VectorExists2<span class="op">(</span>interp<span class="op">,</span> <span class="st">&quot;data&quot;</span><span class="op">))</span>  <span class="op">{</span></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>Rbc_GetVector<span class="op">(</span>interp<span class="op">,</span> <span class="st">&quot;data&quot;</span><span class="op">,</span> <span class="op">&amp;</span>vecPtr<span class="op">)</span> <span class="op">!=</span> TCL_OK<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> TCL_ERROR<span class="op">;</span></span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> <span class="op">(</span>Rbc_CreateVector<span class="op">(</span>interp<span class="op">,</span> <span class="st">&quot;data&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">&amp;</span>vecPtr<span class="op">)</span> <span class="op">!=</span> TCL_OK<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>       <span class="cf">return</span> TCL_ERROR<span class="op">;</span></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a><span class="co"> * Reset the vector. Clients will be notified when Tk is idle.</span></span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a><span class="co"> * TCL_DYNAMIC tells the vector to free the memory allocated</span></span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a><span class="co"> * if it needs to reallocate or destroy the vector.</span></span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>Rbc_ResetVector<span class="op">(</span>vecPtr<span class="op">,</span> newArr<span class="op">,</span> numValues<span class="op">,</span> numValues<span class="op">,</span> TCL_DYNAMIC<span class="op">)</span> <span class="op">!=</span> TCL_OK<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> TCL_ERROR<span class="op">;</span></span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="incompatibilities">Incompatibilities</h2>
<p>In previous versions, if the array variable isn’t global (i.e. local
to a Tcl procedure), the vector is automatically destroyed when the
procedure returns.</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode tcl"><code class="sourceCode tcl"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">proc</span> doit <span class="kw">{}</span> <span class="kw">{</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Temporary vector x</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    vector <span class="ot">x</span>(<span class="dv">10</span>)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">set</span> <span class="ot">x</span>(<span class="dv">9</span>) <span class="fl">2.0</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>      ...</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span></code></pre></div>
<p>This has changed. Variables are not automatically destroyed when
their variable is unset. You can restore the old behavior by setting the
“-watchunset” switch.</p>
</body>
</html>
